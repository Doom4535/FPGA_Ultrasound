{
  "name": "18545-FPGA Ultrasound DAQ & Beamforming System",
  "tagline": "Repo for CMU 18545 FPGA project -- Multi-channel ultrasound data acquisition and beamforming system.",
  "body": "# 18545-FPGA_Ultrasound-DAQ-Beamforming\r\n\r\nRepo for CMU 18545 FPGA project -- Multi-channel ultrasound data acquisition and beamforming system.\r\n\r\nThis repo documents the CMU course project -- 18545 Advanced Digital Design Project.\r\n>\r\n- Project Overview\r\n- Pre-Preparation\r\n- Usage Tutorial\r\n- Design Components In-Depth Instructions\r\n- Conclusion and Future Work\r\n- Acknowledgement\r\n- Bugs Report and Trouble Shooting\r\n- Some Photos\r\n\r\n-----\r\n\r\n## 1. Project Overview\r\nThis project aims to detect the static and moving objects in the room and implement\r\nthe imaging with the beamforming algorithm running on the AVNET &reg; ZedBoard.\r\n\r\n### Motivation\r\nSince this is a logic design and verification course, maybe the best practice is to\r\nperform all the functionalities on the FPGA fabric. But we decide to take the dual-core\r\nadvantage of the ZedBoard, implementing the signal transmission and reception part on\r\nthe fabric, and the signal process and analysis on the Linux host on the ARM core. This\r\nalso gives us the benefit of easily customizing the user interface functionality with\r\nthe user demands, and in the meanwhile keeping the high efficiency parallel computing\r\nwith the FPGA.\r\n\r\n### Framework\r\nThe design consists of both hardware design and software design, *aka.*, the software-\r\nhardware co-design. The hardware design are the signal transmission and reception logic,\r\nincluding the signal generator, the DAC/ADC interface, the data processor, as well as the\r\nmaster controller. The software design are the signal process and analysis procedures,\r\nincluding the data acquisition controller, the digital signal processor, as well as the\r\nbeamformer.\r\n\r\n## 2. Pre-Preparation\r\nBefore working on this design, you need a few prerequisites to get started.\r\n\r\n### Get the board! ...and the hard/soft/misc essentials\r\nWhat you need are\r\n 1. A ZedBoard, with a Zynq-7000 FPGA fabric and a dual-core ARM processor. Although it\r\n is possible to use a different board, changes need to be made accordingly.\r\n 2. Two PMOD DA4 and four PMOD AD2. Or other ADC/DAC parts you prefer.\r\n 3. Two arrays of ultrasonic transcivers. I use two home-made linear arrays with 16 elments each,\r\n each element having the operating frequency at 40 KHz.\r\n 4. An amplifier to amplify the output voltage. I use eight LM351 Op Amps to make a\r\n simple 16-channel non-inverting amplifier with 100 times gain.\r\n 5. A monitor to display, a USB keyboard, a USB mouse, a USB hub.\r\n 6. A breadboard and a lot of wires. I know how these stuff get things messy...\r\n\r\n### Get the Xillybus IP core and the Xillinux ready\r\nIn this part, you need to compile and implement the Xillybus IP core that will be running on the\r\nFPGA fabric (Programming Logic, PL), and install the Xillinux package on the ARM core (\r\nProcessing System, PS).\r\n\r\nPlease follow these steps\r\n\r\n1. Go to [this link](http://xillybus.com/xillinux \"xillybus\") and download the necessary\r\npackages and tools.\r\n2. Carefully follow [this link](http://xillybus.com/downloads/doc/xillybus_getting_started_zynq.pdf)\r\nto setup the Xillinux and the Xillybus. It's lenthy, but pay attention to the *third*\r\nchapter to properly generate the bitstream file, configure the board and load up the\r\nbooting image to the SD card. After this step, you should be able to boot up the\r\nXillinux from the SD card.\r\n> **Note:** After this step, you are **Unable** to directly write the bitstream file to\r\n> the PL via JTAG. Instead, copy and replace your custom bitstream file to the SD card\r\n> with the same filename \"xillydemo.bit\".\r\n\r\n3. Configure the compilation environment. Since Xillinux is essentially the Ubuntu kernel,\r\nyou can configure the environment as you prefer. I always use the [*oh-my-zsh*](\r\nhttp://ohmyz.sh/) and the [*k-vim*](https://github.com/wklken/k-vim).\r\n\r\n## 3. Usage Tutorial\r\nNow you are ready to probe the system. In this step, you need to get yourself familiar\r\nwith the FPGA logic programming and the host programming.\r\n\r\nPlease refer to the following tutorials\r\n\r\n1. [Xillybus FPGA designer's guide](http://xillybus.com/downloads/doc/xillybus_fpga_api.pdf)\r\n2. [Xillybus host application programming guide for Linux](http://xillybus.com/downloads/doc/xillybus_host_programming_guide_linux.pdf)\r\n3. [The guide to defining a custom Xillybus IP core](http://xillybus.com/downloads/doc/xillybus_custom_ip.pdf)\r\n\r\n> **Note:** You should be familiar with the SystemVerilog language as I use it, and knows\r\n> the basics of Verilog and VHDL. Specifically, you should know\r\n\r\n> 1. Design hierarchy. The design under test (dut), the testbench, the top.\r\n> 2. Combinational logic and sequential logic. The \"assigns\" and \"always_combs\", the\r\n> explicit and implicit finite state machines.\r\n> 3. The **VERY** important time synchronization. Good timing is the key to accurate and\r\n> efficient logic.\r\n> 4. FSM-Datapath.\r\n> 5. Interface.\r\n> 6. and most importantly, Testbenches. Knowing how to write a good testbench for hardware\r\n> threads, concurrent threads, use assertions are vital for a decent logic design.\r\n\r\n### Connect the wires\r\nConnect the AD/DA modules, the transcivers, the amplifier, maybe an oscilliscope, and of\r\ncourse, the power.\r\n\r\n### Implement the user logic\r\nThe entire project can be found [here](http://pan.baidu.com/s/1dFlrVhf).\r\n\r\nRun the project under *verilog/vivado/xillydemo.xpr* to generate the bitstream file, and\r\nput it to the SD card.\r\n\r\n### Run the demo script\r\nBoot up the Xillinux and run the Python script under *host_script/run545demo.py*.\r\n\r\nYou should be able to receive the signals from the sensors and perform analysis.\r\n\r\n## 4. Design Components In-Depth Instructions\r\nIn this section, I will walk you through the details in each\r\ndesign module and the host script.\r\n\r\n> **System** **flowchart:** Signal generator --> Pmod DA4 --> Transmitter array\r\n\r\n> Receiver array --> Pmod AD2 --> Data processor --> Xilly reader --> FIFO -->\r\n> Host process\r\n\r\n### Signal reception interface\r\nThe *ad_rcv_intfc* collects all the signals in the data transmission and reception flow,\r\ninterfacing among the signal generator, the DA and AD, the data processor, the xilly\r\nreader, the fifo, the master controller to arduously control the logic.\r\n\r\n### Signal generator\r\nThe signal generator generates a 40 KHz continuous sine wave. Feel free to replace it\r\nwith your custom signal source. Although there are many approaches to this purpose,\r\n*e.g.* PWM, DDS, CORDIC, to name a few, I use a 39-value look-up table with 12 bits\r\nresolution to approximate the sine wave. It turns to be a fairly good approximation.\r\nThe reason to use 39 values is that after calculation I find this gives me an integer\r\ndivisor of 2 to divide the 100 MHz on-board clock in order to generate the 40 KHz signal.\r\n\r\nOn the arrival of the *sig_gen_en* signal from the top level, it addresses *start_gen*\r\nand shift from *idleSt* to *genSt*. It uses a counter to count the number of values it\r\nhas sent out. It acknowledges the *sig_out_rdy* after sending done and waits for the\r\n*da_send_done* from the DA4 module before proceeding to the next generation. Default\r\nstate is the *idleSt*. Reset brings it to the *idleSt*.\r\n\r\n### DA interface\r\nThe pmodDA4 module interfaces with the Pmod DA4 hardware part to convert the signals from\r\nthe signal generator to analog outputs. Please refer [this link](http://www.analog.com/media/en/technical-documentation/data-sheets/AD5628_5648_5668.pdf) to see the protocals\r\ninterfacing with the part.\r\n\r\nThe module takes in a 12 bits signal each time, and sends out a 32 bits data sequence\r\nin serial in 32 clock cycles. The 32 bits sequence consists\r\nthe command, the address, the signal, and the don't-care bits. The FSM has five states.\r\nAt the power on the idle state transits to *stInternalRef* and then *stRefTx* to set the internal\r\nreference for the DA4 part, as required by the manual. It waits at the *stInit* until\r\nthe arrival of the *sig_out_rdy* signal, and proceeds to the *stTx* to send out the data.\r\nIt then addresses the *da_send_done* signal to interface with the signal generator to\r\nstart next signal generation.\r\n\r\n### AD interface\r\nThe slave pmodAD2_ctrl module and the master TWICtl module interface with the Pmod AD2 hardware part to\r\nconvert the analog signals to digital signals.\r\n\r\nPlease refer [this link](http://www.analog.com/media/en/technical-documentation/data-sheets/AD7991_7995_7999.pdf) to see the protocals\r\ninterfacing with the part. It's a little bit complex to handle...\r\n\r\n### Data processor\r\nThe ad_processor module loads 4 bytes of data from AD2 each time, and signals the xilly\r\nreader to pass the data to the 32*512 fifo.\r\n\r\nThe initial purpose of this module is to perform basic windowing and filtering on the\r\nraw data, but, well, you know, time presses...\r\n\r\n### Xilly reader\r\nThis module controls the data follow to the fifo, see [Xillybus FPGA designer's guide](http://xillybus.com/downloads/doc/xillybus_fpga_api.pdf).\r\n\r\n### Master controller\r\nAs its name states, this is the top module connecting all the submodules and interfacing\r\nwith the physical world. This module initializes the wires and registers and submodules.\r\n\r\n### Other modules\r\nClock divider, divide the clocks.\r\n\r\nAd_2_fifo_sender, master control commands to start up the system.\r\n\r\n### Host script\r\nThis Python script first starts the data acquisition for a user defined period of time,\r\nand then decodes the channel and data information from the received data. Afterwards, it\r\nprocesses the data and analyzes the data with user defined algorithm.\r\n\r\nThree threads cooperate to do the task. Multithreading is useful here to leverage the\r\nbottleneck of data transmission throughput between the PL and the PS, and the speed limit\r\nof the PS. Pipelined scheme is preferred.\r\n\r\n## 5. Conclusion and Future Work\r\nThis concludes the entire design of the ultrasound DAQ and beamforming system.\r\n\r\nFuture work\r\n\r\n1. Fix bugs.\r\n2. DSP on PL.\r\n3. Enrich the signal generator vault.\r\n4. Seperate control of signal transmission and reception.\r\n5. The doppler and beamforming algorithms.\r\n\r\n## 6. Acknowledgement\r\nI would like to extend my great gratitude to all the people that support and help me\r\nwith this project. Special thanks go to Prof. Bill Nace in CMU.\r\n\r\n## 7. Bugs Report and Trouble Shooting\r\n1. Large detection range requires high power output.\r\n2. Signal distortion after amplifying.\r\n3. Pay attention to the input and output order of the FIFO.\r\n4. Pay attention to the default case and reset case. Make them safe.\r\n5. Pay attention to the holding signals and temporal signals.\r\n6. Pay attention to the cross time domain synchronization.\r\n7. Pay attention to the usage of x or z.\r\n8. Fake connect the GPIOs to FMC pins in the XDC file.\r\n\r\n## 8. Some photos\r\n![ZedBoard](./pics/0426_7.jpg)\r\n\r\n![Transcivers](./pics/0426_12.jpg)\r\n\r\n![Amplifier](./pics/0426_10.jpg)\r\n\r\n![Generated signal](./pics/0426_3.jpg)\r\n\r\n![DA Timing](./pics/0426_1.jpg)\r\n\r\n![Schematics](./pics/0426_4.jpg)\r\n\r\n![Host process](./pics/0426_6.jpg)\r\n\r\n![Process result](./pics/0426_8.jpg)\r\n\r\n![Poster](./pics/0426_9.jpg)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}